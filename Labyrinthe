#include <iostream>
#include <vector>
#include <string>
#include <stdlib.h>
#include <time.h>
#include <termios.h>
#include <unistd.h>
#include <boost/thread.hpp>
#include <boost/chrono.hpp>

using namespace std;

struct termios saved_attributes;

void
reset_input_mode (void)
{
    saved_attributes.c_lflag |= (ICANON|ECHO);
  tcsetattr (STDIN_FILENO, TCSANOW, &saved_attributes);

}

void set_input_mode (void)
{
  struct termios tattr;

  /* Make sure stdin is a terminal. */
  if (!isatty (STDIN_FILENO))
  {
      fprintf (stderr, "Not a terminal.\n");
      exit (EXIT_FAILURE);
  }

  /* Save the terminal attributes so we can restore them later. */
  tcgetattr (STDIN_FILENO, &saved_attributes);
  atexit (reset_input_mode);

  /* Set the funny terminal modes. */
  tcgetattr (STDIN_FILENO, &tattr);
  tattr.c_lflag &= ~(ICANON|ECHO); /* Clear ICANON and ECHO. */
  tattr.c_cc[VMIN] = 0;
  tattr.c_cc[VTIME] = 3;
  tcsetattr (STDIN_FILENO, TCSAFLUSH, &tattr);
}


namespace
{
    typedef vector <char> CVLine; // un type représentant une ligne de la grille
    typedef vector <CVLine> CMatrix; // un type représentant la grille
    typedef pair   <unsigned, unsigned> CPosition; // un type représentant une coordonnée dans la grille


    void ClearScreen ()
    {
        cout << "\033[H\033[2J";
    }

    const string KReset   ("0");
    const string KNoir    ("30");
    const string KRouge   ("31");
    const string KVert    ("32");
    const string KJaune   ("33");
    const string KBleu    ("34");
    const string KMagenta ("35");
    const string KCyan    ("36");

    const string KFNoir    ("40");
    const string KFRouge   ("41");
    const string KFVert    ("42");
    const string KFJaune   ("43");
    const string KFBleu    ("44");
    const string KFMagenta ("45");
    const string KFCyan    ("46");

    void Couleur (const string & coul)
    {
        cout << "\033[" << coul <<"m";
    }

    const char KTokenPlayer1 = 'X';
    const char KTokenPlayer2 = 'O';
    const char KTokenPlayerI = 'I';
    const char KTokenPlayerA = 'A';
    const char KEmpty        = ' ';
    const char KTiret        = '-';
    const char KPipe         = '|';
    const char KForbidden    = 'G';
    const char KFoW          = 'F';
    const char KWatch        = 'W';
    const char KVictory      = 'V';

    unsigned MatSizeH;
    unsigned MatSizeL;




    const vector< pair<int,int>> PossibleMove = {{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1}};
    const vector<char> PossibleKey = {'a', 'z', 'e', 'd', 'c', 'x', 'w', 'q'};


    void  ShowMatrix (const CMatrix & Mat)
    {
        const string KTiretsLine = string(4*(Mat[0].size()), KTiret);
        ClearScreen ();
        Couleur (KReset);
        cout << KTiretsLine << endl;


        for( unsigned Line(0); Line < Mat.size(); ++Line )
        {
            for( unsigned Col(0); Col < Mat[Line].size(); ++Col)
            {
                cout << KPipe;

                switch(Mat[Line][Col])
                {
                    case KEmpty:
                        break;
                    case KForbidden:
                        Couleur(KNoir);
                        Couleur(KFNoir);
                        break;
                    case KTokenPlayer1 :
                        Couleur(KRouge);
                        break;
                    case KTokenPlayer2 :
                        Couleur(KBleu);
                        break;
                    case KTokenPlayerI :
                        Couleur(KVert);
                        break;
                    case KTokenPlayerA :
                        Couleur(KJaune);
                        break;
                    case KFoW :
                        //Couleur(KFNoir);
                        break;
                    case KWatch :
                        Couleur(KVert);
                        Couleur(KFVert);
                        break;
                    case KVictory :
                        Couleur(KJaune);
                        Couleur(KFJaune);
                        break;

                    default:
                        break;

                }
                cout << KEmpty << Mat[Line][Col] << KEmpty;
                Couleur(KReset);
            }
            cout << KPipe << endl << KTiretsLine << endl;
        }
    } // ShowMatrix

    void InitMat (CMatrix & Mat, const unsigned NbLine, const unsigned NbColumn, const CPosition & PosPlayer1, const CPosition & PosPlayer2,
                  const CPosition & PosPlayerI, const CPosition & PosPlayerA)
    {
        Mat.resize(NbLine);
        for( unsigned Line(0); Line < Mat.size(); ++Line )
        {
            Mat[Line].resize(NbColumn);
            for( unsigned Col(0); Col < Mat[Line].size(); ++Col)
            {
                Mat[Line][Col] = KEmpty;
            }
        }
        Mat[PosPlayer1.first][PosPlayer1.second] = KTokenPlayer1;
        Mat[PosPlayer2.first][PosPlayer2.second] = KTokenPlayer2;
        Mat[PosPlayerI.first][PosPlayerI.second] = KTokenPlayerI;
        Mat[PosPlayerA.first][PosPlayerA.second] = KTokenPlayerA;
    } //InitMat

    bool MoveToken (CMatrix & Mat, char & Move, CPosition  & Pos)
    {
        char Player = Mat[Pos.first][Pos.second];
        Mat[Pos.first][Pos.second] = KEmpty;
        tolower(Move);
        switch(Move)
        {
            case 'a':
                Pos = make_pair(Pos.first + PossibleMove[0].first, Pos.second + PossibleMove[0].second);
                break;
            case 'z':
                Pos = make_pair(Pos.first + PossibleMove[1].first, Pos.second + PossibleMove[1].second);
                break;
            case 'e':
                Pos = make_pair(Pos.first + PossibleMove[2].first, Pos.second + PossibleMove[2].second);
                break;
            case 'd':
                Pos = make_pair(Pos.first + PossibleMove[3].first, Pos.second + PossibleMove[3].second);
                break;
            case 'c':
                Pos = make_pair(Pos.first + PossibleMove[4].first, Pos.second + PossibleMove[4].second);
                break;
            case 'x':
                Pos = make_pair(Pos.first + PossibleMove[5].first, Pos.second + PossibleMove[5].second);
                break;
            case 'w':
                Pos = make_pair(Pos.first + PossibleMove[6].first, Pos.second + PossibleMove[6].second);
                break;
            case 'q':
                Pos = make_pair(Pos.first + PossibleMove[7].first, Pos.second + PossibleMove[7].second);
                break;
            default:
                break;
        }
        Move = 's';
        if(Mat[Pos.first][Pos.second] == KForbidden || Pos.first > Mat.size() - 1 || Pos.second > Mat[0].size() - 1 ||  Mat[Pos.first][Pos.second] == KTokenPlayerA  || Mat[Pos.first][Pos.second] == KTokenPlayerI)
            return false;
        Mat[Pos.first][Pos.second] = Player == KTokenPlayer1 ? KTokenPlayer1 : KTokenPlayer2;
        return true;
    } //MoveToken

    void MoveIA(CMatrix & Mat, const CPosition & PosPlayer, CPosition & PosIA, const unsigned & Turn, const unsigned & Diff)
    {
        CPosition Dist;
        CPosition PosTemp;
        PosTemp = make_pair(PosIA.first, PosIA.second);
        bool SignX(PosPlayer.first > PosIA.first); // Vrai si le Joueur se trouve en bas de l'IA
        bool SignY(PosPlayer.second > PosIA.second); // Vrai si le Joueur se trouve à droite de l'IA

        Dist = make_pair( SignX ? PosPlayer.first - PosIA.first : PosIA.first - PosPlayer.first, SignY ? PosPlayer.second - PosIA.second : PosIA.second - PosPlayer.second );
        // Dist prend pour valeur la distance qui sépare l'IA du joueur qui le pourchasse en X et en Y

        unsigned Incr(0); // Sers à passer au mouvement suivant si le mouvement courant est impossible


        switch(Diff)
            {
                case 0 : // Cas IA facile
                {

                    if((Turn+2)%4 > 1 ) // Condition pour faire jouer les IA un tour sur deux
                    {

                        do
                        {
                            if (Dist.first > Dist.second) // Si le joueur est plus loin en hauteur qu'en longueur
                                PosTemp = make_pair(PosIA.first + PossibleMove[SignX ? ((5+Incr)%8) : ((1+Incr)%8)].first, PosIA.second + PossibleMove[SignX ? ((5+Incr)%8) : ((1+Incr)%8)].second);
                            else if (Dist.first < Dist.second) // Si le joueur est plus loin en longueur qu'en hauteur
                                PosTemp = make_pair(PosIA.first + PossibleMove[SignY ? ((3+Incr)%8) : ((7+Incr)%8)].first, PosIA.second + PossibleMove[SignY ? ((3+Incr)%8) : ((7+Incr)%8)].second);
                            Incr += 2;
                            if ( Incr > 8)
                                return;
                        }while(Mat[PosTemp.first][PosTemp.second] == KForbidden || Mat[PosTemp.first][PosTemp.second] == KTokenPlayerA || Mat[PosTemp.first][PosTemp.second] == KTokenPlayerI
                               || PosTemp.first > Mat.size() || PosTemp.second > Mat[0].size());

                    }
                    else return;
                    break;
                }
                case 1 : // Cas IA moyen ( déplacement interdit en diagonale )
                {
                    do
                    {
                        if (Dist.first > Dist.second) // Si le joueur est plus loin en hauteur qu'en longueur
                            PosTemp = make_pair(PosIA.first + PossibleMove[SignX ? ((5+Incr)%8) : ((1+Incr)%8)].first, PosIA.second + PossibleMove[SignX ? ((5+Incr)%8) : ((1+Incr)%8)].second);
                        else if (Dist.first < Dist.second) // Si le joueur est plus loin en longueur qu'en hauteur
                            PosTemp = make_pair(PosIA.first + PossibleMove[SignY ? ((3+Incr)%8) : ((7+Incr)%8)].first, PosIA.second + PossibleMove[SignY ? ((3+Incr)%8) : ((7+Incr)%8)].second);
                        Incr += 2;
                        if (Incr > 8)
                            return;
                    }while(Mat[PosTemp.first][PosTemp.second] == KForbidden || Mat[PosTemp.first][PosTemp.second] == KTokenPlayerA || Mat[PosTemp.first][PosTemp.second] == KTokenPlayerI
                           || PosTemp.first > Mat.size() || PosTemp.second > Mat[0].size());
                    break;
                }
                case 2 : // Cas IA difficile ( Tout déplacement autorisé )
                {
                    do
                    {
                        if((Dist.first != 0) && (Dist.second != 0)) // Si le joueur n'est ni sur la même ligne ni sur la même colonne
                        {
                            if(!(SignX))
                                PosTemp = make_pair(PosIA.first + PossibleMove[SignY ? ((2+Incr)%8) : ((0+Incr)%8)].first, PosIA.second + PossibleMove[SignY ? ((2+Incr)%8) : ((0+Incr)%8)].second);
                            else if(SignX)
                                PosTemp = make_pair(PosIA.first + PossibleMove[SignY ? ((4+Incr)%8) : ((6+Incr)%8)].first, PosIA.second + PossibleMove[SignY ? ((4+Incr)%8) : ((6+Incr)%8)].second);
                        }
                        else if (Dist.first > Dist.second) // Si le joueur est plus loin en hauteur qu'en longueur
                            PosTemp = make_pair(PosIA.first + PossibleMove[SignX ? ((5+Incr)%8) : ((1+Incr)%8)].first, PosIA.second + PossibleMove[SignX ? ((5+Incr)%8) : ((1+Incr)%8)].second);
                        else if (Dist.first < Dist.second) // Si le joueur est plus loin en longueur qu'en hauteur
                            PosTemp = make_pair(PosIA.first + PossibleMove[SignY ? ((3+Incr)%8) : ((7+Incr)%8)].first, PosIA.second + PossibleMove[SignY ? ((3+Incr)%8) : ((7+Incr)%8)].second);
                        if (++Incr >8)
                            return;
                    }while(Mat[PosTemp.first][PosTemp.second] == KForbidden || Mat[PosTemp.first][PosTemp.second] == KTokenPlayerA || Mat[PosTemp.first][PosTemp.second] == KTokenPlayerI
                           || PosTemp.first > Mat.size() || PosTemp.second > Mat[0].size());
                    break;
                }
                default :
                    break;
        }

        Mat[PosIA.first][PosIA.second] = KEmpty;

        PosIA = make_pair(PosTemp.first, PosTemp.second);


        Mat[PosIA.first][PosIA.second] = Turn%2==0 ? KTokenPlayerA : KTokenPlayerI;

    } // MoveIA

    void DisableCase(CMatrix & Mat, const CPosition & Pos1, const CPosition & Pos2, const CPosition & PosI, const CPosition & PosA)
    {
        CPosition ForbiddenCase;
        do
        {

            srand (time(NULL));
            ForbiddenCase = make_pair(rand() % (Mat.size()-1), rand() % (Mat[0].size()-1));
        } while(ForbiddenCase == Pos1 || ForbiddenCase == Pos2 || ForbiddenCase == PosI || ForbiddenCase == PosA  ||Mat[ForbiddenCase.first][ForbiddenCase.second] == KForbidden
                || (ForbiddenCase.first == 0 && ForbiddenCase.second == MatSizeL-1) || (ForbiddenCase.first == MatSizeH-1 && ForbiddenCase.second == 0) );

        Mat[ForbiddenCase.first][ForbiddenCase.second] = KForbidden;


    } //DisableCase





    bool WinTest(const bool & Move,const CPosition & Pos1,const CPosition & Pos2, const CPosition & PosI,const CPosition & PosA, const unsigned & NbTurn)
    {
        if(!Move)
        {
            cout << "Le joueur "<< (NbTurn%2 == 0 ? 2 : 1) << " est entré sur une case interdite ou est sorti des limites du terrain." << endl;
            cout << "Le joueur "<< (NbTurn%2 == 0 ? 1 : 2) << " a gagné !" << endl;
            return true;
        }
        else if(Pos1 == Pos2)
        {
            cout << "Le joueur "<< (NbTurn%2 == 0 ? 2 : 1) << " a mangé le joueur "  << (NbTurn%2 == 0 ? 1 : 2)  << endl;
            cout << "Le joueur "<< (NbTurn%2 == 0 ? 2 : 1) << " a gagné !" << endl;
            return true;
        }
        else if(Pos1 == PosA || Pos2 == PosA || Pos1 == PosI || Pos2 == PosI )
        {
            cout << " Le joueur " << (NbTurn%2==0 ? (PosA == Pos1 ? 1 : 2) : (PosI == Pos1 ? 1 : 2)) << " s'est fait mangé par l'IA "
                                  << (NbTurn%2==0 ? ((PosA == Pos2) ? 'A' : 'I') : (PosA == Pos1) ? 'A' : 'I') << endl;
            cout << "Le joueur "<< (NbTurn%2==0 ? (PosA == Pos1 ? 2 : 1) : (PosI == Pos1 ? 2 : 1)) << " a gagné !" << endl;
            return true;
        }
        else if ((Pos1.first  == MatSizeH -1 && Pos1.second == 0) || (Pos2.first == 0 && Pos2.second == MatSizeL -1))
        {
            cout << "Le joueur " << (NbTurn%2==0 ? 2 : 1) << " est entré dans le camp de l'adversaire." << endl;
            cout << "Le joueur " << (NbTurn%2==0 ? 2 : 1) << " a gagné !" << endl;
            return true;
        }

        return false;

    } //WinTest
/*
    void Timer(unsigned & sec)
    {
        sleep(5);
        cout << --sec << "-";
    }
*/
    bool MoveCheck(char & MoveKey)
    {
        for(const char & Key : PossibleKey)
            if (Key == MoveKey) return true;
        return false;
    }

    bool CptTurn(unsigned & Turn, unsigned & sec, char & MoveKey)
    {
        bool TurnPass(false);
        if(--sec == 0)
        {
            cout << "Votre tour est terminé, c'est au tour du joueur suivant." << endl;
            sec = 10;
            ++Turn;
            TurnPass = true;
        }
        else if (MoveCheck(MoveKey))
        {
            sec = 10;
            ++Turn;
            TurnPass = true;
        }
        cout << "Tour : " << Turn << endl
             << "Il vous reste " << sec << " secondes pour jouer." << endl;
        return TurnPass;
    } //CptTurn

    void Invite( const unsigned & Turn)
    {

        cout << "Joueur " << (Turn%2 == 0 ? "Rouge" : "Bleu") << " : Entrez une touche :" << endl;

    } //Invite

    bool IsInMat(CMatrix & Mat, CPosition & Pos)
    {
        if(Pos.first > Mat.size() || Pos.second > Mat[0].size())
            return false;
        return true;
    }


    bool IsAllowed(CMatrix & Mat, CPosition & Pos)
    {
        if (IsInMat(Mat, Pos) && Mat[Pos.first][Pos.second] != KForbidden && Mat[Pos.first][Pos.second] != KTokenPlayerA && Mat[Pos.first][Pos.second] != KTokenPlayerI)
            return true;
        return false;
    }

    void FogOfWar(CMatrix & Mat,const CPosition & Pos)
    {
        for(CVLine & Line : Mat)
            for(char & Case : Line)
                if(Case == KEmpty) Case = KFoW;
        for(unsigned i (0); i < PossibleMove.size(); ++i)
        {
            pair<int,int> AroundPosInt;
            AroundPosInt = make_pair(Pos.first + PossibleMove[i].first, Pos.second + PossibleMove[i].second);
            CPosition AroundPos = CPosition(AroundPosInt);
            if (!(IsInMat(Mat, AroundPos))) continue;
            if( Mat[AroundPos.first][AroundPos.second] == KFoW) Mat[AroundPos.first][AroundPos.second] = KEmpty;
            for(unsigned j(0); j < 3; ++j)
            {
                CPosition PosTemp = make_pair(AroundPos.first - 1,AroundPos.second);
                if (!(IsInMat(Mat, PosTemp))) continue;
                if(i < 3 && IsInMat(Mat, PosTemp) && Mat[AroundPos.first - 1][AroundPos.second] == KFoW ) Mat[AroundPos.first - 1][AroundPos.second] = KEmpty;
                PosTemp = make_pair(AroundPos.first,AroundPos.second + 1);
                if (!(IsInMat(Mat, PosTemp))) continue;
                if(i > 1 && i < 5 && IsInMat(Mat, PosTemp) && Mat[AroundPos.first][AroundPos.second + 1] == KFoW) Mat[AroundPos.first][AroundPos.second + 1] = KEmpty;
                PosTemp = make_pair(AroundPos.first + 1,AroundPos.second);
                if (!(IsInMat(Mat, PosTemp))) continue;
                if(i > 3 && i < 7 && IsInMat(Mat, PosTemp) && Mat[AroundPos.first + 1][AroundPos.second] == KFoW) Mat[AroundPos.first + 1][AroundPos.second] = KEmpty;
                PosTemp = make_pair(AroundPos.first,AroundPos.second - 1);
                if (!(IsInMat(Mat, PosTemp))) continue;
                if((i == 0 || (i > 5  && i <= 8)) && IsInMat(Mat, PosTemp) && Mat[AroundPos.first][AroundPos.second - 1] == KFoW) Mat[AroundPos.first][AroundPos.second - 1] = KEmpty;

            }
        }

    }

    void SetCases(CMatrix & Mat, CPosition & Victory, CPosition & Watch)
    {
        if(Mat[Victory.first][Victory.second] != KTokenPlayer1 && Mat[Victory.first][Victory.second] != KTokenPlayer2 ) Mat[Victory.first][Victory.second] = KVictory;

        if(Mat[Watch.first][Watch.second] != KTokenPlayer1 && Mat[Watch.first][Watch.second] != KTokenPlayer2 ) Mat[Watch.first][Watch.second] = KWatch;
    }

    void UnFog(CMatrix & Mat, CPosition & Watch)
    {
        if(Mat[Watch.first][Watch.second] == KTokenPlayer1 || Mat[Watch.first][Watch.second] == KTokenPlayer2)
            for(CVLine & Line : Mat)
                for(char & Case : Line)
                    if(Case == KFoW) Case = KEmpty;
    }

    bool WinTestLab(const bool & Move,const CPosition & Pos1,const CPosition & Pos2, const CPosition & PosVict, const unsigned & NbTurn)
    {
        if(!Move)
        {
            cout << "Le joueur "<< (NbTurn%2 == 0 ? 2 : 1) << " est entré sur une case interdite ou est sorti des limites du terrain." << endl;
            cout << "Le joueur "<< (NbTurn%2 == 0 ? 1 : 2) << " a gagné !" << endl;
            return true;
        }
        else if (Pos1 == Pos2)
        {
            cout << "Le chasseur a tué sa proie, il a donc gagné.";
            return true;
        }
        else if (Pos1 == PosVict)
        {
            cout << "La proie s'est échappée, bravo à elle";
            return true;
        }
    }//WinTestLab

    void Labyrinth(CMatrix & Mat, CPosition & Victory, CPosition & Watch)
    {
        Mat.resize(20);
        for (CVLine & Line : Mat)
            Line.resize(10);

        srand (time(NULL));
        unsigned LabType = 1; //rand()%4;
        if (LabType == 0)
        {

            for (unsigned Line (0); Line < Mat.size(); ++Line)
            {
                for (unsigned i(0); i<Mat[Line].size(); ++i)
                {
                    CPosition PosTemp = make_pair(Line, i);
                    if (IsInMat(Mat, PosTemp) && Mat[Line][i] != KTokenPlayer1 && Mat[Line][i] != KTokenPlayer2) Mat[Line][i] = KForbidden;
                }
            }


               for (unsigned Line (0); Line <= 3; ++Line)
                   if(Mat[Line][3] == KForbidden) Mat[Line][3] = KEmpty;
               for (unsigned Line (3); Line <= 6; ++Line)
                   if(Mat[Line][4] == KForbidden) Mat[Line][4] = KEmpty;
               for (unsigned Line (6); Line <= 11; ++Line)
                   if(Mat[Line][3] == KForbidden) Mat[Line][3] = KEmpty;
               for (unsigned Line (11); Line <= 13; ++Line)
                   if(Mat[Line][4] == KForbidden) Mat[Line][4] = KEmpty;
               for (unsigned Line (13); Line <= 16; ++Line)
                   if(Mat[Line][5] == KForbidden) Mat[Line][5] = KEmpty;
               for (unsigned Line (16); Line <= 18; ++Line)
                   if(Mat[Line][4] == KForbidden) Mat[Line][4] = KEmpty;
               for (unsigned Column (4); Column <= 8; ++Column)
                   if(Mat[18][Column] == KForbidden) Mat[18][Column] = KEmpty;
               for (unsigned Column (6); Column <= 7; ++Column)
                   if(Mat[10][Column] == KForbidden) Mat[10][Column] = KEmpty;
               for (unsigned Line (9); Line <= 10; ++Line)
                   if(Mat[Line][6] == KForbidden) Mat[Line][6] = KEmpty;
               for (unsigned Line (18); Line >= 8; --Line)
                   if(Mat[Line][8] == KForbidden) Mat[Line][8] = KEmpty;
               for (unsigned Column (8); Column >= 1; --Column)
                   if(Mat[8][Column] == KForbidden) Mat[8][Column] = KEmpty;
               for (unsigned Line (8); Line <= 12; ++Line)
                   if(Mat[Line][1] == KForbidden) Mat[Line][1] = KEmpty;
               for (unsigned Line (12); Line <= 14; ++Line)
                   if(Mat[Line][0] == KForbidden) Mat[Line][0] = KEmpty;
               for (unsigned Line (14); Line <= 16; ++Line)
                   if(Mat[Line][1] == KForbidden) Mat[Line][1] = KEmpty;
               for (unsigned Line (16); Line <= 19; ++Line)
                   if(Mat[Line][2] == KForbidden) Mat[Line][2] = KEmpty;
               Victory = make_pair(19, 2);
               Watch = make_pair(10, 6);
        }
        else if (LabType == 1)
        {
            for (unsigned Line (0); Line < Mat.size(); ++Line)
            {
                for (unsigned i(0); i<Mat[Line].size(); ++i)
                {
                    CPosition PosTemp = make_pair(Line, i);
                    if (IsInMat(Mat, PosTemp) && Mat[Line][i] != KTokenPlayer1 && Mat[Line][i] != KTokenPlayer2) Mat[Line][i] = KEmpty;
                }
            }
            for (unsigned Column (1); Column <= 8; ++Column)
                if(Mat[1][Column] == KEmpty) Mat[1][Column] = KForbidden;
            for (unsigned Column (1); Column <= 3; ++Column)
                if(Mat[3][Column] == KEmpty) Mat[3][Column] = KForbidden;
            for (unsigned Column (5); Column <= 9; ++Column)
                if(Mat[3][Column] == KEmpty) Mat[3][Column] = KForbidden;
            for (unsigned Line (1); Line <= 5; ++Line)
                if(Mat[Line][1] == KEmpty) Mat[Line][1] = KForbidden;
            for (unsigned Column (1); Column <= 6; ++Column)
                if(Mat[5][Column] == KEmpty) Mat[5][Column] = KForbidden;
            for (unsigned Line (5); Line <= 18; ++Line)
                if(Mat[Line][6] == KEmpty) Mat[Line][6] = KForbidden;
            for (unsigned Column (8); Column <= 9; ++Column)
                if(Mat[5][Column] == KEmpty) Mat[5][Column] = KForbidden;
            for (unsigned Column (6); Column <= 8; ++Column)
                if(Mat[7][Column] == KEmpty) Mat[7][Column] = KForbidden;
            for (unsigned Column (8); Column <= 9; ++Column)
                if(Mat[9][Column] == KEmpty) Mat[9][Column] = KForbidden;
            for (unsigned Column (6); Column <= 8; ++Column)
                if(Mat[11][Column] == KEmpty) Mat[11][Column] = KForbidden;
            for (unsigned Column (8); Column <= 9; ++Column)
                if(Mat[13][Column] == KEmpty) Mat[13][Column] = KForbidden;
            for (unsigned Column (6); Column <= 8; ++Column)
                if(Mat[15][Column] == KEmpty) Mat[15][Column] = KForbidden;
            for (unsigned Column (8); Column <= 9; ++Column)
                if(Mat[17][Column] == KEmpty) Mat[17][Column] = KForbidden;
            for (unsigned Column (0); Column <= 4; ++Column)
                if(Mat[8][Column] == KEmpty) Mat[8][Column] = KForbidden;
            for (unsigned Column (0); Column <= 4; ++Column)
                if(Mat[11][Column] == KEmpty) Mat[11][Column] = KForbidden;
            for (unsigned Column (0); Column <= 4; ++Column)
                if(Mat[14][Column] == KEmpty) Mat[14][Column] = KForbidden;
            for (unsigned Column (0); Column <= 4; ++Column)
                if(Mat[16][Column] == KEmpty) Mat[16][Column] = KForbidden;
            for (unsigned Column (1); Column <= 6; ++Column)
                if(Mat[18][Column] == KEmpty) Mat[18][Column] = KForbidden;
            for (unsigned Line (18); Line <= 19; ++Line)
                if(Mat[Line][3] == KEmpty) Mat[Line][3] = KForbidden;
            Victory = make_pair(19, 4);
            Watch = make_pair(19, 2);
        }
    }//Labyrinth

    void Input(char & MoveKey)
    {
        do
        {

        read (STDIN_FILENO, &MoveKey, 1);
        }while(!(MoveCheck(MoveKey)));

    } //Input





    int ppal ()
    {

        CMatrix Mat;
        MatSizeH =20;
        MatSizeL =10;
        CPosition Pos1 (4,4);
        CPosition Pos2 (19,6);
        CPosition PosI (0,0);
        CPosition PosA (MatSizeH -1,MatSizeL -1);
        unsigned NbTurn(1);
        unsigned Diff(2);
        unsigned Sec(10);

        char MoveKey('s');
        bool AllowedMove(true);
        bool TurnPass(false);
        bool GameOver(false);
        //sleep(5);
        InitMat(Mat, MatSizeH, MatSizeL, Pos1, Pos2, PosI, PosA);

        set_input_mode();

        /*while(!(GameOver))
        {
            sleep(1);
            ShowMatrix(Mat);

            TurnPass = CptTurn(NbTurn, Sec, MoveKey);
            //boost::thread ThTimer{boost::bind(Timer, boost::ref(Sec))};
            Invite(NbTurn);
            cout << MoveKey << endl;
            boost::thread ThInput{boost::bind(Input, boost::ref(MoveKey))};

            if(!(TurnPass) && !(MoveCheck(MoveKey))) continue;
            AllowedMove = MoveToken(Mat, MoveKey, NbTurn%2 == 0 ? Pos2 : Pos1);

            ShowMatrix(Mat);


            GameOver = WinTest(AllowedMove, Pos1, Pos2, PosI, PosA, NbTurn);


            MoveIA(Mat, NbTurn%2 == 0 ? Pos2 : Pos1, NbTurn%2 == 0 ? PosA : PosI, NbTurn, Diff);

            ShowMatrix(Mat);

            GameOver = WinTest(AllowedMove, Pos1, Pos2, PosI, PosA, NbTurn);

            DisableCase(Mat, Pos1, Pos2, PosI, PosA);


        }
        cout << "Partie terminee" << endl;

        reset_input_mode();
        sleep(10);
        return 0;*/
        CPosition Victory;
        CPosition Watch;
        Labyrinth(Mat, Victory, Watch);
        FogOfWar(Mat, Pos2);
        SetCases(Mat, Victory, Watch);

        while(!(GameOver))
                {
                    sleep(1);
                    ShowMatrix(Mat);

                    TurnPass = CptTurn(NbTurn, Sec, MoveKey);
                    //boost::thread ThTimer{boost::bind(Timer, boost::ref(Sec))};
                    Invite(NbTurn);
                    cout << MoveKey << endl;
                    boost::thread ThInput{boost::bind(Input, boost::ref(MoveKey))};

                    if(!(TurnPass) && !(MoveCheck(MoveKey))) continue;
                    AllowedMove = MoveToken(Mat, MoveKey, NbTurn%2 == 0 ? Pos2 : Pos1);
                    FogOfWar(Mat, NbTurn%2 == 0 ? Pos1 : Pos2);
                    SetCases(Mat, Victory, Watch);
                    UnFog(Mat, Watch);
                    WinTestLab(AllowedMove, Pos1, Pos2, Victory, NbTurn);

                    ShowMatrix(Mat);

                    GameOver = WinTest(AllowedMove, Pos1, Pos2, PosI, PosA, NbTurn);

                }



        ShowMatrix(Mat);

        cout << "Partie terminee" << endl;
        return 0;
    } //ppal

}

int main()
{
    ppal();
    return 0;
}
